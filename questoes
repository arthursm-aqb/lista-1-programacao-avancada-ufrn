Aluno: Arthur da Silva Mariz - DCA0803 T01

Questão 1.
A importância do aprendizado da utilidade do uso dos ponteiros na engenharia é na flexibilidade dos recursos computacionais. A linguagem C permite a interação direta com o ponteiro, por exemplo - o engenheiro precisa atualizar algum valor de um programa ao decorrer do tempo, com o uso dos ponteiros não é necessário realocar outros diversos valores para realizar a tarefa pedida, é preciso somente de jogar a informação necessária para onde o ponteiro já está atuando.

Questão 2.
A. p == &i; \\O valor do endereço da variável p é igual a de i ou p = 3, p = 3 = i = 3;
B. *p - *q;\\A variável "p" recupera o valor do ponteiro apontado a ela, a variável "q" acontece o mesmo, sendo assim, representadas pelo seguinte conteúdo, p = 3 e q = 5. O valor final dessa operação de *p - *q é igual à -2;
C. **&p;\\Essa expressão terá o valor de 3;
D. 3 - *p/(*q) + 7;\\O valor dessa expressão é 10.

Questão 3.
Os valores encontrados a partir da expressão dada pela questão são: 62fe1c, 7, 5, 15, 9.

Questão 4.
As expressões com atribuições invalidas são as alternativas "b, d, e, f e h".

Questão 5. 
Os valores encontrados pelas expressões citadas na questão são:
a= 20; 
b= 29.0;
c= p;
d= e;
e= p;
f= e;
g= t;
h= 31;
i= 45;
j= 27;
l= 31;
m= 45;
n= 45.

Questão 6.
Os valores encontrados de "i = %d" são -> 0, 1, 2, 3 e 4;
Os valores encontrados dos arrays "vet[%d] = %.1f" são -> 1.1, 2.2, 3.3, 4.4 e 5.5;
Os valores encontrados da representação alternativa dos arrays "*(f + %d) = %.1f" são -> 1.1, 2.2, 3.3, 4.4 e 5.5;
Os valores encontrados do endereço hexadecimal da memória dos vetores "&vet[%d] = %x" são -> 79FDF0, 79FDF4, 79FDF8, 79FDFC e 79FD00;
Os valores encontrados da representação alternativa do endereço hexadecimal da memória dos vetores "(f + %d) = %x" são -> 79FDF0, 79FDF4, 79FDF8, 79FDFC e 79FD00.

Questão 7.
A expressão que referencia o 3 elemento do vetor pulo é a primeira opção: "*(pulo+2)".

Questão 8.
Somente a expressão que irei citar na resposta é valida, as outras expressões são todas invalidas por causa do "`" que é um simbolo operacional que não existe na linguagem C;
a. A expressão "p = mat + 1" é valida porque é a atribuição de array do vetor para o ponteiro, no entanto, com uma peculariedade - por ter um "mat+1" na atribuição, o ponteiro irá receber só o conteúdo do 2 espaço da memória do vetor.

Questão 9.
a. O primeiro programa é usado para mostrar os valores que possui dentro do array do vetor "vet", e para isso é utilizado um laço for e um printf com "*(vet+i)" que é a representação alternativa de vet[i];
b. O segundo programa é usado para mostrar o endereço de memória  dos valores do vetor "vet", é usado para mostrar isso um laço e "%x" dentro do printf, além da representação alternativa do vet[i] - "*(vet+i).

Questão 10.
Programando um código para imprimir os valores do endereços da memória de cada expressão dos 4 tipos diferentes de variáveis, os seguintes valores foram achados:
Tipo int    -   x+1 = 000000000079FDF4, x+2 = 000000000079FDF8, x+3 = 000000000079FDFC;
Tipo char   -   y+1 = 000000000079FDED, y+2 = 000000000079FDEE, y+3 = 000000000079FDEF;
Tipo float  -   z+1 = 000000000079FDD4, z+2 = 000000000079FDD8, z+3 = 000000000079FDDC;
Tipo double -   c+1 = 000000000079FDB8, c+2 = 000000000079FDC0, c+3 = 000000000079FDC8.

Questão 11.
a. aloha[2]=value; -> Válida;
b. scanf("%f", &aloha); -> Inválida;
c. aloha = "value"; -> Inválida;
d. printf ("f", aloha); -> Válida;
e. coisas[4][4] = aloha[3]; -> Válida;
f. coisas[5] = aloha; -> Inválida;
g. pf = value; -> Inválida;
h. pf = aloha; -> Válida.

Questão 12.
O ponteiro para uma função significa que podemos definir quando será executado uma função específica que o ponteiro esteja apontando, sem deixar ela vísivel no código, além da possibilidade de passar valores de uma função para outras.

Exemplo 1:
int diferenca(int x, int y) // Função para onde o ponteiro irá apontar.
{
    int c;
    c= x-y;
    printf ("%d\n", c);
}

int main()
{
    int a, b;
    int (*p) (int, int); // Declarado o ponteiro de funções onde recebe dois parâmetros inteiros.
    p = diferenca; // É atribuido ao ponteiro a função diferença.
    printf ("Digite dois números para a váriavel a e b:\n");
    scanf ("%d %d", &a, &b);
    p(a,b); // Acionando o ponteiro, não precisa citar o nome da função, ele vai realizar o papel de uma função já que recebeu o endereço da função "diferença". Por fim, ele retorna os valores obtidos dentro da função. 
    return 0;
}

Exemplo 2:
int ponteiro (int (*p)(int, int), int x, int y) // É declarado uma função ponteiro de dois inteiros, onde existe uma associação entre a função ponteiro e uma função normal que recebe duas variáveis inteiras que vão ser repassadas para a função ponteiro.
{
    return p(x, y); // A função retorna dois parâmetros da função normal associada a função ponteiro que agora pode ser alocada em outras funções.
}

int diferenca (int a, int b) // Uma função normal que retorna a diferença entre dois valores a e b.
{
    int c;
    c = a-b;
    printf ("%d\n", c);
}

int main()
{
    int n1, n2; // As variaveis que vão ser utilizadas pela função ponteiro
    printf ("Digite dois números para a váriavel a e b:\n");
    scanf ("%d %d", &n1, &n2);
    ponteiro(diferenca, n1, n2); // Aqui a função ponteiro é executada e aponta para a função diferença, dessa forma, executando o código da função diferença utilizando os parâmetros "x e y" que ela recebeu.
    return 0;
}

Questão 13.

#include <stdio.h>
#include <stdlib.h>

float ordbubblesort()
{
	float *numeros, x;
	int aux;
	
	
	printf("Digite quantos números racionais você vai querer ordernar em ordem crescente: ");
	scanf("%d", &aux);
	numeros = (float *) malloc(aux*sizeof(float));
	for(int i=0; i<aux; i++)
	{
		printf ("\nDigite o %d número: ", i+1);
		scanf("%f", &numeros[i]);
		printf ("\n");
	}
	
	for(int z=0; z<aux; z++) 
	{
   		for(int j=0; j<aux-1; j++) 
		{
     		if(numeros[j]>numeros[j + 1]) 
			{
       			x = numeros[j];
       			numeros[j] = numeros[j + 1];
       			numeros[j + 1] = x;
     		}
   		}
 	}
	
	printf("\nNúmeros racionais em ordem crescente:\n");
	for (int c=0; c<aux; c++) 
	{
 		printf("%.2f\t", numeros[c]);
	}
	printf("\n");
	free(numeros);
	
}


int main()
{
	ordbubblesort();
	return 0;
}

Questão 14.

#include <stdio.h>
#include <stdlib.h>

float comparar(const void* a, const void* b)//Array de troca de posições na memória para ordernar os valores em ordem crescente.
{
	if (*(float*)a == *(int*)b)
	{
		return 0;//Se o valor A e o valor B forem iguais, a função retorna "0", que significa que não acontecera a troca de posição.
	}
		else if (*(float*)a<*(float*)b)
		{
			return -1;//Se o valor de B for maior que A, a função retorna "-1", que significa a troca de posição entre o B e A.
		}
			else
			{
				return 1;//Senão for nenhuma das anteriores, então A é maior que B, dessa forma a função retorna "1" que significa a troca de posição entre A e B.
			}
}

int main()
{
	float *numeros;
	int aux;
	//O inteiro aux vai ser usado para guardar a quantidade de números que o usuário deseja ordernar, enquanto isso, numeros será um ponteiro usado para a alocação dinâmica da memória.
	
	printf("Digite quantos números racionais você vai querer ordernar em ordem crescente: ");
	scanf("%d", &aux);
	numeros = (float *) malloc(aux*sizeof(float));//É reservado um tamanho n na memória para o ponteiro que aponta para float "numeros".
	for(int i=0; i<aux; i++)
	{
		printf ("\nDigite o %d número: ", i+1);
		scanf("%f", &numeros[i]);
		printf ("\n");
	}
	//Um laço simples para guardar os valores que o usuário deseja ordernar de forma crescente.
	qsort(numeros, aux, sizeof(float), comparar);
	//O comando qsort recebe o array "numeros" para o qual irá apontar em seu endereço de memória, após isso, é especificado o tamanho do array "aux" e o número de bytes presente nessa operação. Por fim, é especificado a função comparar que irá retornar os valores -1, 0 ou 1, no qual o qsort utiliza para saber se irá realizar a troca de posições.
	printf("\nNúmeros racionais em ordem crescente:\n");
	for(int c=0; c<aux; c++) 
	{
 		printf("%.2f\t", numeros[c]);
	}
	//Laço usado para imprimir os valores de forma crescente.
	printf("\n");
    free(numeros);//Comando utilizado para limpar a memória e evitar o risco de acontecer vazamento de memória.
	return 0;
}

Questão 15.

